<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>My Project: zsim</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">zsim </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>zsim is a fast x86-64 simulator. It was originally written to evaluate ZCache (Sanchez and Kozyrakis, MICRO-44, Dec 2010), hence the name, but it has since outgrown its purpose. zsim's main goals are to be fast, simple, and accurate, with a focus on simulating memory hierarchies and large, heterogeneous systems. It is parallel and uses DBT extensively, resulting in speeds of hundreds of millions of instructions/second in a modern multicore host. Unlike conventional simulators, zsim is organized to scale well (almost linearly) with simulated core count.</p>
<p>You can find more details about zsim in our ISCA 2013 paper: <a href="http://people.csail.mit.edu/sanchez/papers/2013.zsim.isca.pdf">http://people.csail.mit.edu/sanchez/papers/2013.zsim.isca.pdf</a>.</p>
<h2>License &amp; Copyright </h2>
<p>zsim is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.</p>
<p>zsim was originally written by Daniel Sanchez at Stanford University, and per Stanford University policy, the copyright of this original code remains with Stanford (specifically, the Board of Trustees of Leland Stanford Junior University). Since then, zsim has been substantially modified and enhanced at MIT by Daniel Sanchez, Nathan Beckmann, and Harshad Kasture. zsim also incorporates contributions on main memory performance models from Krishna Malladi, Makoto Takami, and Kenta Yasufuku.</p>
<p>zsim was also modified and enhanced while Daniel Sanchez was an intern at Google. Google graciously agreed to share these modifications under a GPLv2 license. This code is (C) 2011 Google Inc. Files containing code developed at Google have a different license header with the correct copyright attribution.</p>
<p>Additionally, if you use this software in your research, we request that you reference the zsim paper ("ZSim: Fast and Accurate Microarchitectural
Simulation of Thousand-Core Systems", Sanchez and Kozyrakis, ISCA-40, June 2013) as the source of the simulator in any publications that use this software, and that you send us a citation of your work.</p>
<h2>Setup </h2>
<p>External dependencies: <code>gcc &gt;=4.6, pin, scons, libconfig, libhdf5, libelfg0</code></p>
<p><b>Natively:</b> If you use a relatively recent Linux distribution:</p>
<ol type="1">
<li>Clone a fresh copy of the git zsim repository (<code>git clone &lt;path to zsim repo&gt;</code>).</li>
<li><p class="startli">Download Pin, <a href="http://www.pintool.org">http://www.pintool.org</a> . Tested with Pin 2.8+ on an x86-64 architecture. Compiler flags are set up for Pin 2.9 on x86-64. To get flags for other versions, examine the Pin makefile or derive from sample pintools. Set the PINPATH environment variable to Pin's base directory.</p>
<p class="startli">NOTE: Linux 3.0+ systems require Pin 2.10+, just because Pin does a kernel version check that 3.0 fails. Use Pin 2.12 with Sandy/Ivy Bridge systems, earlier Pin versions have strange performance regressions on this machine (extremely low IPC).</p>
</li>
<li><p class="startli">zsim requires some additional libraries. If they are not installed in your system, you will need to download and build them:</p>
<p class="startli">3.1 libconfig, <a href="http://www.hyperrealm.com/libconfig">http://www.hyperrealm.com/libconfig</a>. You may use the system's package if it's recent enough, or build your own. To install locally, untar, run <code>./configure --prefix=&lt;libconfig install path&gt; &amp;&amp; make install</code>. Then define the env var <code>LIBCONFIGPATH=&lt;libconfig install path&gt;</code>.</p>
<p class="startli">3.2 libhdf5, <a href="http://www.hdfgroup.org">http://www.hdfgroup.org</a> (v1.8.4 path 1 or higher), and libelfg0. The SConstruct file assumes these are installed in the system.</p>
<p class="startli">3.3 (OPTIONAL) polarssl (currently used just for their SHA-1 hash function), <a href="http://www.polarssl.org">http://www.polarssl.org</a> Install locally as in 3.1 and define the env var <code>POLARSSLPATH=&lt;polarssl install path&gt;</code>.</p>
<p class="startli">NOTE: You may need to add <code>-fPIC</code> to the Makefile's C(PP/XX)FLAGS depending on the version.</p>
<p class="startli">3.4 (OPTIONAL) DRAMSim2 for main memory simulation. Build locally and define the env var DRAMSIMPATH as in 3.1 and 3.3.</p>
</li>
<li>In some distributions you may need to make minor changes to the host configuration to support large shmem segments and ptrace. See the notes below for more details.</li>
<li>Compile zsim: <code>scons -j16</code></li>
<li>Launch a test run: <code>./build/opt/zsim tests/simple.cfg</code></li>
</ol>
<p>For more compilation options, run scons &ndash;help. You can build debug, optimized and release variants of the simulator (&ndash;d, &ndash;o, &ndash;r options). Optimized (opt) is the default. You can build profile-guided optimized (PGO) versions of the code with &ndash;p. These improve simulation performance with OOO cores by about 30%.</p>
<p>NOTE: zsim uses C++11 features available in <code>gcc &gt;=4.6</code> (such as range-based for loops, strictly typed enums, lambdas, and type inference). Older version of gcc will not work. zsim can also be built with <code>icc</code> (see the <code>SConstruct</code> file).</p>
<p><b>Using a virtual machine:</b> If you use another OS, can't make system-wide configuration changes, or just want to test zsim without modifying your system, you can run zsim on a Linux VM. We have included a vagrant configuration file (<a href="http://vagrantup.com">http://vagrantup.com</a>) that will provision an Ubuntu 12.04 VM to run zsim. You can also follow this Vagrantfile to figure out how to setup zsim on an Ubuntu system. Note that <b>zsim will be much slower on a VM</b> because it relies on fast context-switching, so we don't recommend this for purposes other than testing and development. Assuming you have vagrant installed (<code>sudo apt-get install vagrant</code> on Ubuntu or Debian), follow these:</p>
<ol type="1">
<li>Copy <code>misc/Vagrantfile</code> from the repo into an empty folder.</li>
<li>Run <code>vagrant up</code> to set up the base VM and install all dependencies.</li>
<li>SSH into the VM with <code>vagrant ssh</code>.</li>
<li>Inside the VM, you can clone the zsim repo, and build it and use it as usual (steps 1, 5, and 6 above).</li>
</ol>
<h2>Notes </h2>
<p><b>Accuracy &amp; validation:</b> While we have validated zsim against a real system, you should be aware that we sometimes sacrifice some accuracy for speed and simplicity. The ISCA 2013 paper details the possible sources of inaccuracy. Despite our validation efforts, if you are using zsim with workloads or architectures that are significantly different from ours, you should not blindly trust these results. Also, zsim can be configured with varying degrees of accuracy, which may be OK in some cases but not others (e.g., longer bound phases to reduce overheads are often OK if your application has little communication, but not with fine-grained parallelism and synchronization). Finally, in some cases you will need to modify the code to model what you want, and for some purposes, zsim is just not the right tool. In any case, we strongly recommend validating your baseline configuration and workloads against a real machine.</p>
<p>In addition to the results in the zsim paper, <a href="http://zsim.csail.mit.edu/validation">http://zsim.csail.mit.edu/validation</a> has updated validation results.</p>
<p><b>Memory Management:</b> zsim can simulate multiple processes, which introduces some complexities in memory management. Each Pin process uses SysV IPC shared memory to communicate through a global heap. Be aware that Pin processes have a global and a process-local heap, and all simulator objects should be allocated in the global heap. A global heap allocator is implemented (galloc.c and g_heap folder) using Doug Lea's malloc. The global heap allocator functions are as the usual ones, with the gm_ prefix (e.g. gm_malloc, gm_calloc, gm_free). Objects can be allocated in the global heap automatically by making them inherit from <a class="el" href="classGlobAlloc.html">GlobAlloc</a>, which redefines the new and delete operators. STL classes use their own internal allocators, so they cannot be members of globally visible objects. To ease this, the g_stl folder has template specializations of commonly used STL classes that are changed to use our own STL-compliant allocator that allocates from the global heap. Use these classes as drop-in replacements when you need a globally visible STL class, e.g. substitute std::vector with <a class="el" href="classg__vector.html">g_vector</a>, etc.</p>
<p><b>Harness:</b> While most of zsim is implemented as a pintool (<code>libzsim.so</code>), a harness process (<code>zsim</code>) is used to control the simulation: set up the shared memory segment, launch pin processes, check for deadlock, and ensure termination of the whole process tree when it is killed. In prior revisions of the simulator, you could launch the pintool directly, but now you should use the harness.</p>
<p><b>Transparency &amp; I/O:</b> To maintain transparency w.r.t instrumented applications, zsim does all logging through info/warn/panic methods. With the sim.logToFile option, these dump to per-process log files instead of the console. <em>You should never use cout/cerr or printf in simulator code</em> &mdash; simple applications will work, but more complex setups, e.g., anything that uses pipes, will break.</p>
<p><b>Interfacing with applications:</b> You can use special instruction sequences to control the simulation from the application (e.g., fast-forward to the region you want to simulate). <code>misc/hooks</code> has wrappers for C/C++, Fortran, and Java, and extending this to other languages should be easy.</p>
<p><b>Host Configuration:</b> The system configuration may need some tweaks to support zsim. First, it needs to allow for large shared memory segments. Second, for Pin to work, it must allow a process to attach to any other from the user, not just to a child. Use sysctl to ensure that <code>kernel.shmmax=1073741824</code> (or larger) and <code>kernel.yama.ptrace_scope=0</code>. zsim has mainly been used in Ubuntu 11.10, 12.04, 12.10, 13.04, and 13.10, but it should work in other Linux distributions. Using it in OSs other than Linux (e.g,, OS X, Windows) will be non-trivial, since the user-level virtualization subsystem has deep ties into the Linux syscall interface.</p>
<p><b>Stats:</b> The simulator outputs periodic, eventual and end-of-sim stats files. Stats can be output in both HDF5 and plain text. Read the README.stats file and the associated scripts repository to see how to use these stats.</p>
<p><b>Configuration &amp; Getting Started:</b> A detailed use guide is out of the scope of this README, because the simulator options change fairly often. In general, <em>the documentation is the source code</em>. You should be willing to occasionally read the source code to see how different zsim features work. To get familiar with the way to configure the simulator, the following three steps usually work well when getting started:</p>
<ol type="1">
<li>Check the examples in the <code>tests/</code> folder, play around with the settings, and launch a few runs. <a class="el" href="classConfig.html">Config</a> files have three sections, sys (configures the simulated system, e.g., core and cache parameters), sim (configures simulation parameters, e.g., how frequent are periodic stats output, phase length, etc.), and process{0, 1, 2, ...} entries (what processes to run).</li>
<li>Most parameters have implicit defaults. zsim produces an out.cfg file that includes all the default choices (and we recommend that your analysis scripts automatically parse this file to check that what you are simulating makes sense). Inspecting the out.cfg file reveals more configuration options to play with, as well as their defaults.</li>
<li>Finally, check the source code for more info on options. The whole system is configured in the init.cpp (sys and sim sections) and process_tree.cpp (processX sections) files, so there is no need to grok the whole simulator source to find out all the configuration options.</li>
</ol>
<p><b>Hacking &amp; Style Guidelines:</b> zsim is mostly consistent with Google's C++ style guide. You can use cpplint.py to check rule violations. We depart from these guidelines on a couple of aspects:</p>
<ul>
<li>4-space indentation instead of 2 spaces</li>
<li>120-character lines instead of 80-char (though you'll see a clear disregard for strict line length limits every now and then)</li>
</ul>
<p>You can use cpplint.py (included in misc/ with slight modifications) to check your changes. misc/ also has a script to tidy includes, which should be in alphabetical order within each type (own, system, and project headers).</p>
<p>vim will indent the code just fine with the following options: <code>set cindent shiftwidth=4 expandtab smarttab</code></p>
<p>Finally, as Google's style guidelines say, please be consistent with the current style used elsewhere. For example, the parts of code that deal with Pin follow a style consistent with pintools.</p>
<p>Happy hacking, and hope you find zsim useful! </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 28 2015 08:15:37 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
